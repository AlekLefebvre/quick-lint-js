// Copyright (C) 2020  Matthew "strager" Glazar
// See end of file for extended copyright information.

#include <cstdio>
#include <cstdlib>
#include <quick-lint-js/cli/arg-parser.h>
#include <quick-lint-js/cli/cli-location.h>
#include <quick-lint-js/container/hash-map.h>
#include <quick-lint-js/container/linked-vector.h>
#include <quick-lint-js/container/padded-string.h>
#include <quick-lint-js/container/string-view.h>
#include <quick-lint-js/container/vector.h>
#include <quick-lint-js/io/file.h>
#include <quick-lint-js/io/output-stream.h>
#include <quick-lint-js/reflection/cxx-parser.h>
#include <quick-lint-js/util/algorithm.h>
#include <string_view>
#include <vector>

using namespace std::literals::string_view_literals;

namespace quick_lint_js {
namespace {
void write_po_string_literal(Output_Stream&, String8_View);

struct String_Table {
  void add_string(String8_View string, const char* origin_file_path) {
    auto existing_it = this->string_to_entry.find(string);
    Entry* entry;
    if (existing_it == this->string_to_entry.end()) {
      entry = &this->entries.emplace_back(string, &this->allocator_);
      auto [_it, inserted] =
          this->string_to_entry.try_emplace(entry->string, entry);
      QLJS_ASSERT(inserted);
    } else {
      entry = existing_it->second;
    }

    if (!contains(entry->origin_file_paths, origin_file_path)) {
      entry->origin_file_paths.push_back(origin_file_path);
    }
  }

  struct Entry {
    // Copies the string.
    explicit Entry(String8_View string, Monotonic_Allocator* allocator)
        : origin_file_paths("String_Table::Entry::file_paths", allocator) {
      Char8* new_string =
          allocator->allocate_uninitialized_array<Char8>(string.size());
      Char8* new_string_end =
          std::copy(string.begin(), string.end(), new_string);
      this->string = make_string_view(new_string, new_string_end);
    }

    Bump_Vector<const char*, Monotonic_Allocator> origin_file_paths;
    String8_View string;
  };

  Linked_Vector<Entry> entries{&this->allocator_};
  Hash_Map<String8_View, Entry*> string_to_entry;

  Monotonic_Allocator allocator_{"String_Table::allocator_"};
};

void find_strings_in_file(const char* input_path,
                          String_Table& out_string_table) {
  Result<Padded_String, Read_File_IO_Error> file = read_file(input_path);
  if (!file.ok()) {
    std::fprintf(stderr, "fatal: %s\n", file.error_to_string().c_str());
    std::exit(1);
  }
  CLI_Locator locator(&*file);

  Padded_String_View remaining = &*file;
  for (;;) {
    static constexpr String8_View marker = u8"QLJS_TRANSLATABLE("_sv;
    std::size_t marker_index = remaining.string_view().find(marker);
    if (marker_index == String8_View::npos) {
      break;
    }
    std::size_t string_index = marker_index + marker.size();
    remaining = remaining.substr(narrow_cast<Padded_String_Size>(string_index));

    CXX_Lexer lexer(remaining, input_path, &locator);
    if (lexer.peek().type != CXX_Token_Type::string_literal) {
      lexer.fatal();
    }
    out_string_table.add_string(lexer.peek().decoded_string, input_path);
    remaining =
        Padded_String_View(lexer.remaining(), remaining.null_terminator());
  }
}

void write_messages_po_template(const String_Table& strings,
                                Output_Stream& out) {
  out.append_copy(
      u8R"(# Code generated by tools/update-translator-sources. DO NOT EDIT.
# source: (various)
# quick-lint-js finds bugs in JavaScript programs.
# Copyright (C) 2020  Matthew "strager" Glazar
#
# This file is part of quick-lint-js.
#
# quick-lint-js is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# quick-lint-js is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with quick-lint-js.  If not, see <https://www.gnu.org/licenses/>.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: strager.nds@gmail.com\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
)"_sv);

  strings.entries.for_each([&](const String_Table::Entry& entry) {
    for (const char* origin_file_path : entry.origin_file_paths) {
      out.append_copy(u8"\n#: "_sv);
      out.append_copy(to_string8_view(origin_file_path));
    }
    out.append_copy(u8"\nmsgid "_sv);
    write_po_string_literal(out, entry.string);
    out.append_copy(u8"\nmsgstr \"\"\n"_sv);
  });
}

void write_po_string_literal(Output_Stream& out, String8_View string) {
  out.append_copy(u8'"');
  for (Char8 c : string) {
    if (c == u8'"' || c == u8'\\') {
      out.append_copy(u8'\\');
      out.append_copy(c);
    } else {
      // TODO(strager): Escape other characters?
      out.append_copy(c);
    }
  }
  out.append_copy(u8'"');
}
}
}

int main(int argc, char** argv) {
  using namespace quick_lint_js;

  std::vector<const char*> input_paths;
  const char* output_messages_pot_path = nullptr;
  Arg_Parser parser(argc, argv);
  QLJS_ARG_PARSER_LOOP(parser) {
    QLJS_ARGUMENT(const char* argument) { input_paths.push_back(argument); }

    QLJS_OPTION(const char* arg_value, "--output-messages-pot"sv) {
      output_messages_pot_path = arg_value;
    }

    QLJS_UNRECOGNIZED_OPTION(const char* unrecognized) {
      std::fprintf(stderr, "error: unrecognized option: %s\n", unrecognized);
      std::exit(2);
    }
  }

  String_Table string_table;
  for (const char* input_path : input_paths) {
    find_strings_in_file(input_path, string_table);
  }

  {
    Result<Platform_File, Write_File_IO_Error> messages_pot =
        open_file_for_writing(output_messages_pot_path);
    if (!messages_pot.ok()) {
      std::fprintf(stderr, "error: %s\n",
                   messages_pot.error_to_string().c_str());
      std::exit(1);
    }
    File_Output_Stream out(messages_pot->ref());
    write_messages_po_template(string_table, out);
    out.flush();
  }
}

// quick-lint-js finds bugs in JavaScript programs.
// Copyright (C) 2020  Matthew "strager" Glazar
//
// This file is part of quick-lint-js.
//
// quick-lint-js is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// quick-lint-js is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with quick-lint-js.  If not, see <https://www.gnu.org/licenses/>.
